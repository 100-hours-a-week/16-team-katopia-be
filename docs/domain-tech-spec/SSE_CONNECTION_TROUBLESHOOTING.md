# SSE Connection Troubleshooting

## 목적
- SSE 연결이 끊겼을 때 서버가 이를 즉시 알지 못하는 문제를 기록한다.
- 유령 연결(ghost connection) 누적과 과도한 연결 수로 인한 리소스 낭비를 줄이는 설계를 정리한다.

## 문제 정의
- 클라이언트가 SSE 연결을 끊어도 서버는 이를 즉시 알지 못한다.
- 서버는 끊긴 emitter로 전송을 시도하고, 전송 실패를 통해서만 종료를 감지한다.
- 다수의 재연결/탭 복제/네트워크 변경이 누적되면 유효하지 않은 연결이 서버에 남는다.

## 가설
- "연결 상태를 서버 외부(공유 저장소)로 관리"하면 다중 인스턴스에서도 정리/제한을 강제할 수 있다.
- "가장 오래된 연결을 선제적으로 종료"하면 리소스 누수를 제한할 수 있다.

## 대응 전략
- Redis ZSET을 연결 레지스트리로 사용한다.
- 사용자당 최대 연결 수를 제한하고 초과분은 즉시 제거한다.
- 제거 대상은 Pub/Sub으로 전파하여 실제 연결을 보유한 인스턴스가 종료한다.

## 설계 결정
- 키/값 구조
  - 키: `sse:notification:{memberId}`
  - 값(ZSET): `connectionId(UUID)` -> `connectedAt(epoch ms)`
- 연결 제한
  - 사용자당 최대 3개 연결
  - 초과 시 `ZPOPMIN`으로 가장 오래된 연결 제거
- 종료 전파
  - 채널: `sse:notification:disconnect`
  - 메시지: `{memberId}|{connectionId}`

## 적용 방식
- SSE 연결 생성 시
  - Redis에 연결 등록(ZADD)
  - 연결 수 확인(ZCARD)
  - 초과분 제거(ZPOPMIN)
  - 제거된 연결은 Pub/Sub 전파
- SSE 종료 수신 시
  - 로컬 connectionId 매칭 후 emitter 종료
  - Redis에서 해당 연결 제거(ZREM)

## 운영 기준
- SSE 타임아웃: 30분
- 하트비트: 20초 간격 ping
- 정리 주기: SSE 생존시간 * 2

## 기대 효과
- 유령 연결 누적 방지
- 다중 인스턴스에서도 전역 연결 제한 보장
- 클라이언트 재연결 폭주 시 리소스 보호

## 사례: 새로고침으로 연결 급증
- 증상: 클라이언트 새로고침마다 서버의 연결 수가 증가한다.
- 원인: Next.js는 페이지 이동이 SPA 방식이라 연결 재사용이 가능하지만, 새로고침은 프로세스를 새로 띄워 SSE 연결을 다시 생성한다.
- 확인: Redis의 SSE 연결 수와 톰캣 연결 수가 함께 증가하는 것을 모니터링으로 확인했다.
- 대응: 사용자당 최대 3개로 제한하고, 초과 연결은 Redis Pub/Sub으로 오래된 연결 종료를 전파했다. Redis 중앙 레지스트리로 연결 상태를 관리해 다중 인스턴스에서도 일관되게 정리한다.

## 한계
- Redis 장애 시 실시간 전송은 비활성화되며 알림함 조회로 대체한다.
- Pub/Sub은 best-effort이므로 전파 실패는 재시도하지 않는다.
